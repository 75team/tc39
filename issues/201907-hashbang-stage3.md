# Hashbang 提案的问题

- 提交者：@hax
- 360TC状态：尚未讨论

## 简介

[Hashbang 提案](https://github.com/tc39/proposal-hashbang) 允许脚本的第一行是如下形式：

```js
#!/usr/bin/env node
'use strict';
console.log(1);
```

即如果第一行是以`#!`开头的话，忽略第一行。

这基本上是当前 node.js 等 CLI 的行为。

Hashbang 提案在2018年3月达到 stage 2，同年11月达到 stage 3，Chrome 74+ 和 Firefox 67+ 已实现。

## 问题

`#!` 必须在脚本的最开始，之前不能有任何内容，包括但不限于注释、换行、空白、BOM等。否则会因为 invalid token 而产生 SyntaxError。

这是能正常执行的脚本：
```html
<script>#! ...
console.log(ok)
</script>
```

以下均是 SyntaxError：
```html
<script>
#! ...
console.log(ok)
</script>

<script>// copyright 2019 hax
#! ...
console.log(ok)
</script>

<script>/*debug info generated by server*/#! ...
console.log(ok)
</script>
```

注意上面用inline script做例子，但也适用于引用外部脚本的情形。

## 组件转换JS导致的问题

在现实世界中，各种预处理器，服务器SSI，第三方组件等，均可能对脚本 prepend/append 一些内容，例子包括：

- 统一前置版权和许可说明
- 加入服务器端信息方便开发人员调试
- 简单的文件合并
- 并非故意，但因各种因素无意前置换行符

当原始内容包含 hashbang `#!`，转换后内容中 `#!` 就不再在文件最开始，从而导致 SyntaxError。要避免这个问题，需要涉及的所有组件在转换时都对 hashbang 做特殊处理，这可能是不现实的。

短期来说，这一风险并不显著，因为组件转换通常用于在浏览器中执行的脚本，而目前所有使用 `#!` 的用例仅限于 CLI 的入口脚本。但长期来说，可能会有一些同时适用于 CLI 和浏览器环境的脚本会因为引入 hashbang 而遭受问题。

## 先例

CSS的 [`@charset "xxx"` 机制](https://drafts.csswg.org/css-syntax/#determine-the-fallback-encoding)类似于 `#!`，必须严格在文件首。但这个例子有个重要不同：

`@charset "xxx"` 不在文件首只是会使得charset声明无效，但并不一定导致整个CSS文件解析失败。事实上，UTF-16文件只能以BOM来提供编码信息，而不能依赖charset声明。而其他的常见编码（UTF-8、ISO-8859-x、Shift-JIS、GBK等）均是ASCII兼容编码，因此不正确的解码只是导致少部分乱码，但CSS整体上仍然是可以工作的。

从历史的角度看，HTML/CSS/JS 的前置或后置 whitespace 从来不会导致整体性的解析失败。进一步说，JS前置和后置注释、换行、空白等从来不会改变JS的解析结果和语义。从某种程度上说，这也应该被视为一种 web compatibility 的要求。

## 可能的解决方案

1. 不限定 `#!` 必须在文件首，而是按spec附录中的 HTML-like Comments 类似的方式来处理，具体来说可采用与`-->`（[SingleLineHTMLCloseComment](https://tc39.es/ecma262/#prod-annexB-SingleLineHTMLCloseComment)）相同的grammar（将 `-->` 换为 `#!`）。
1. 撤销 hashbang 提案，hashbang 需求仍像现在一样由 CLI 自行处理。开发者知晓 hashbang 只能用于特定 CLI 的入口脚本，而不会期待一般的 JS 文件可以带有 hashbang。
